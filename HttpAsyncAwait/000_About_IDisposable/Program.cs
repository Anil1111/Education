
using System;

namespace _000_About_IDisposable
{
    class MyClass : IDisposable
    {
        public void Dispose()
        {
            throw new NotImplementedException();
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            /*
             Использование деструкторов в наших программах не всегда оказывается целесообразно.
             Почему? Потому, что диструктор вызывается непредсказуемо! Мы не знаем когда GC вызовет диструктор.
             Например: если мы откроем соединение к БД и в деструкторе будем его закрывать, то не факт, что деструктор
             будет вызван до конца работы программы! А ПРОГРАММЫ МОГУТ РАБОТАТЬ И МЕСЯЦАМИ!
             А может куча не заполнится и GC скажет "я не пойду на кучу, там ещё памяти много свободной!"

             Можно  было бы вызвать метож GC.Collect() - но это не очень хорошая идея. Почему?
             Пример с хомячком в заклееной черной банке - мы не знаем когда он поел и если будем его заставлять есть - то это плохо.
             Он испортит себе желудок - пусть живет своей жизнью.
             ПОЭТОМУ Microsoft не рекомендует вмешиваться в работу сборки мусора потому, что это может привести к замедлению выполняющихся программ!

             Для этого Microsoft предоставили интерфейс для финализации - IDisposable в котором есть один абстрактный метод Dispose.
             Microsoft рекомендует использовать реализацию интерфейса для освобождения ресурсов.

             Оператор using используется для создания блока кода, в котором создаются объекты, для которых гарантировано будет
             вызван метод IDisposable.Dispose(). Объекты, которые создаются в блоке using ОБЯЗАТЕЛЬНО ДОЛЖНЫ РЕАЛИЗОВЫВАТЬ ИНТЕРФЕЙС IDisposable.
             */
            using (MyClass instance = new MyClass())
            {
                //Использование instance
            } //instance.Dispose(); - вызывается неявно

        }
    }
}
