using System;
using System.Collections.Generic;

namespace _035_LargeObjectHeap
{
    //В куче для маленьких объектов объекты сначала помечаются, а потом удаляются методом СЖАТИЯ(ДИФРАЗМЕНТАЦИИ). В куче для больших объектов такого нету, она НЕ ДЕФРАГМЕНТИРУЕМА.

    //Есть куча для больших объектов, а есть куча для маленьких объектов.
    //Если объект большой - то его двигать, передвагать из одного поколения в другое - затратная операция по времени.
    //По этому большие объекты не двигаются и находятся в отдельной куче - куче для больших объектов.
    class Program
    {
        static void Main(string[] args)
        {
            long[] obj = new long[10000000];

            Console.WriteLine(obj.ToString());

            //Проверяем, что проверок в каждом поколее не было вообще!
            for (int i = 0; i < 3; i++)
            {
                Console.WriteLine($"Проверок сделано в поколении {i} = {GC.CollectionCount(i)}");
            }


            Console.WriteLine($"Объект {obj} находится в поколении {GC.GetGeneration(obj)}");
        }
        //пример сжатия(дефрагментирования) кучи для малых объектов: было ********№№№№№№№№№№!!!!!!!!!!!, мы решаем удалить объект №№№№№№№№№№
        //-и делаем это ********___________!!!!!!!!!!! а теперь дефрагментируем - сжимаем  и получается так:  ********!!!!!!!!!!!

        //куча для больших объектов не сжимается(т.к не дефраментируется) и со временем использования получается ЭФФЕКТ ФРАГМЕНТАЦИИ
        // было *****%%%%????????? я удалил %%%% => *****_____????????? и теперь мне надо ставить @@@@@@@@@@@ , а он не поместиться в _____ по этому
        //выносим его наперед и получается так: *****_____?????????@@@@@@@@@@@ и со временем получаются пустые места в куче, которые не заняты т.к куча не дефрагментируется
        //ЭТОТ ЭФФЕКТ НАЗЫВАЕТСЯ ЭФФЕКТОВ ФРАГМЕНТАЦИИ
        //Например у меня на куче для больших объектов есть ____ мест на 200 кб и я хочу записать туда новый объект размеров 50 кб, но я не могу туда его записать
        //потому, что нету свободного одного целого куска на 50кб!!!

        //С версии .NET 4.5 в настройках можно выбрать опцию сжатия кучи для больших объектов, но это будет требовать больше времени. 
        //Если другого выхода нет и мы работаем с большими объектами - то это может помочь.

        //На эффект фрагментации оцечень легко папасть при работе с большими коллекциями. Подумай, что просходит если я добавляю в коллекцию роазмером 100000 элементов ещё один,
        //а потом ещё один. В этом случае 2 стары массива размером 100000 и 100001 будут удалены с памяти, но оставят "большие дыры" и это увиличивеет размер ОЗУ, которая используется 
        //для нашего приложения.
        //Нужно использовать свойство Capacity, с помощбю которого создастью сразу большую коллекцию и будет раширяться без удаления/создания большим массивов.
        List<string> a = new List<string>{Capacity = 99999};
    }
}
