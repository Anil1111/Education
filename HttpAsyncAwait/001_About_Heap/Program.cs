
namespace _001_About_Heap
{
    class Program
    {
        static void Main(string[] args)
        {
            /*
             Управляемая куча в .NET разделяется на 2 подкучи: ДЛЯ БОЛЬШИХ ОБЪЕКТОВ и ДЛЯ МАЛЕНЬКИХ ОБЪЕКТОВ.

            КУЧА ДЛЯ МАЛЕНЬКИХ ОБЪЕКТОВ
            Эта куча состоит из областей, которые называются поколениями областей(генерациями):
            - Поколение(генерация) 2, Поколение(генерация) 1, Поколение(генерация) 0
                       10мб                    2мб                       256кб
             Размеры могут меняться либо в меньшую либо в большую сторону взависимости от версии .NET и конфигурации компьютера.

            Сначала Garbage Collector заходит в  Поколение(генерация) 0 и:
            - убивает те объекты, которые не будут использоваться далее(на них уже ничего не ссылается)
            - передвагает в Поколение(генерация) 1 те, которые будут дальше использоваться(на них что-то ссылается).
            Считается, что в Поколение(генерация) 0 объекты, которые живут меньше всего.
            Почему так? Потому, что в Поколение(генерация) 0 очень часто используются временные переменные и объекты по слабым ссылкам.
            
            И так повторяется всегда. Garbage Collector ИДЕТ ТУДА, ГДЕ ЗАКАНЧИВАЕТСЯ СВОБОДНОЕ МЕСТО(ПАМЯТЬ).
            А почему не постоянно он ходит? Почему только тогда, когда заканчивается память? 
            Потому, что действия Garbage Collector`a  тоже бываюют трудоемкими: объекты передвигаются - 
            например объект был в Поколение(генерация) 0 и прошел проверку и попал в Поколение(генерация) 1.
            Нужно в переменных в программе, которые ссылаются на данные объекты ПОМЕНЯТЬ ССЫЛКИ НА ОБЪЕКТЫ(когда объект передвагиется в другую генерацию МЕНЯЕТСЯ ЕГО АДРЕС!)!

            Ну и вообще, если Поколение(генерация) не заполнено, то Garbage Collector может и не зайти и не проверить.
            Зачем? Память ещё не заполнена.
             */
        }
    }
}
