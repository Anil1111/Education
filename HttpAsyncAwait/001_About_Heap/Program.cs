
using System;
using System.Net.Http;

namespace _001_About_Heap
{
    class Program
    {
        /*
             Управляемая куча в .NET разделяется на 2 подкучи: ДЛЯ БОЛЬШИХ ОБЪЕКТОВ и ДЛЯ МАЛЕНЬКИХ ОБЪЕКТОВ.

            КУЧА ДЛЯ МАЛЕНЬКИХ ОБЪЕКТОВ

            Эта куча состоит из областей, которые называются поколениями областей(генерациями):
            - Поколение(генерация) 2, Поколение(генерация) 1, Поколение(генерация) 0
                       10мб                    2мб                       256кб
             Размеры могут меняться либо в меньшую либо в большую сторону взависимости от версии .NET и конфигурации компьютера.

            Сначала Garbage Collector заходит в  Поколение(генерация) 0 и:
            - убивает те объекты, которые не будут использоваться далее(на них уже ничего не ссылается)
            - передвагает в Поколение(генерация) 1 те, которые будут дальше использоваться(на них что-то ссылается).
            Считается, что в Поколение(генерация) 0 объекты, которые живут меньше всего.
            Почему так? Потому, что в Поколение(генерация) 0 очень часто используются временные переменные и объекты по слабым ссылкам.
            
            И так повторяется всегда. Garbage Collector ИДЕТ ТУДА, ГДЕ ЗАКАНЧИВАЕТСЯ СВОБОДНОЕ МЕСТО(ПАМЯТЬ).
            А почему не постоянно он ходит? Почему только тогда, когда заканчивается память? 
            Потому, что действия Garbage Collector`a  тоже бываюют трудоемкими: объекты передвигаются - 
            например объект был в Поколение(генерация) 0 и прошел проверку и попал в Поколение(генерация) 1.
            Нужно в переменных в программе, которые ссылаются на данные объекты ПОМЕНЯТЬ ССЫЛКИ НА ОБЪЕКТЫ(когда объект передвагиется в другую генерацию МЕНЯЕТСЯ ЕГО АДРЕС!)!

            Ну и вообще, если Поколение(генерация) не заполнено, то Garbage Collector может и не зайти и не проверить.
            Зачем? Память ещё не заполнена.
            ---------------------------------------------------------------------------------------------------------
            
            КУЧА ДЛЯ БОЛЬШИХ ОБЪЕКТОВ(Large Object Heap)

            !!!!Любые объекты размером 85000 Байт = (83КБ) и более считаются большими. Т.е все объекты, которые меньше 83кб
            будут размещаться на куче малых объектов.
            КУЧА ДЛЯ БОЛЬШИХ ОБЪЕКТОВ состоит из одного поколения - и это поколение 2.
            Почему так? Потому, что считается, что большие объекты создаются для того, чтобы жить долго.

            !!ПРАВИЛО!! КУЧА ДЛЯ БОЛЬШИХ ОБЪЕКТОВ не дефрагментируемая! Допустим у меня есть место на 90 кб и где-то в 
            далеке место на 85 кб, а мне нужно впихнуть объект на 100 кб. Нельзя "подвинуть" объекты, чтобы 
            получилось одно пространство на 90+85=175кб. И если реально не будет хватать памяти - то будет ошибка т.к объекты двигаться не будут!
            Нужно сразу резевировать место для больших объектов, например
            сразу создать коллекцию на большое количество элементов.

            КУЧА ДЛЯ МАЛЫХ ОБЪЕКТОВ ДЕФРАГМЕНТИРУЕМА, а КУЧА ДЛЯ БОЛЬШИХ ОБЪЕКТОВ - НЕ ДЕФРАГМЕНТИРУЕМА.

            ---------------------------------------------------------------------------------------------------------
            Garbage Collector
            System.GC - класс для правления сбором мусора.

            Позволяет получать информацию о поколениях, а так же принудательно инициировать сбор мусора.
            Кроме того, позволяет отменять работу деструктора объекта.
            Но ЭТО ОЧЕНЬ ПЛОХО - ВМЕШИВАТЬСЯ В РАБОТУ  Garbage Collector`а. Особенно если я не знаю на какой машине 
            будет крутиться моя приложуха и какие приложения там будут ещё. 
            Если на машине будет работать только моё приложение(например электронный киоск) - тогда вмешательство в работу GC допустимо.
             */
        static void Main(string[] args)
        {
            Object a = new Byte[85000];
            Console.WriteLine(GC.GetGeneration(a)); //выводит 2, а не 0
        }
    }
}
